import{_ as a,o as s,c as n,X as e}from"./chunks/framework.6e839c56.js";const l="/assets/format_png.bcb05f46.png",o="/assets/image-20221020153848095.c852a06e.png",t="/assets/7fc93da14eb34a1387df0ea5e1e9e7fatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.42f25785.webp",p="/assets/watermark_type_ZmFuZ3poZW5naGVpdGk_shadow_10_text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3YxMjM0MTE3Mzk__size_16_color_FFFFFF_t_70.38b11ce4.png",r="/assets/watermark_type_ZmFuZ3poZW5naGVpdGk_shadow_10_text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3YxMjM0MTE3Mzk__size_16_color_FFFFFF_t_70-16666893633985.be4081f1.png",c="/assets/1ba741e8ec35f72293957059b6685e38.a0eb6784.png",i="/assets/1620.ade5b35f.png",u="/assets/36a712dbdff642048611a26849294d1e.2bb0a8ab.png",h="/assets/image-20221027164521781.2c0cb031.png",C="/assets/171729fc868d44b7tplv-t2oaga2asx-zoom-in-crop-mark4536000.df6395e5.webp",d="/assets/image-20220801164155012.aa9025e6.png",A="/assets/image-20220801170004517.5c7b5b62.png",b="/assets/image.a75d7c11.png",y="/assets/image2.51a59601.png",D="/assets/image4.2684f2e8.png",g="/assets/image3.bc59eb95.png",q="/assets/image5.df309f83.png",k="/assets/image6.f17043e5.png",m="/assets/image7.a85e8b0e.png",F="/assets/image8.898ece06.png",f="/assets/image9.ceb6428d.png",x="/assets/image-20230129110956423.49e6fff2.png",P="/assets/6282f947d73bc.7efc0905.png",v="/assets/6282f960a1656.65050230.png",S="/assets/synchronized.82accfaa.png",N=JSON.parse('{"title":"Java","description":"","frontmatter":{},"headers":[],"relativePath":"data/后端/java.md","filePath":"data/后端/java.md"}'),E={name:"data/后端/java.md"},_=e(`<h1 id="java" tabindex="-1">Java <a class="header-anchor" href="#java" aria-label="Permalink to &quot;Java&quot;">​</a></h1><h2 id="关键字" tabindex="-1">关键字 <a class="header-anchor" href="#关键字" aria-label="Permalink to &quot;关键字&quot;">​</a></h2><h3 id="volatile" tabindex="-1">volatile <a class="header-anchor" href="#volatile" aria-label="Permalink to &quot;volatile&quot;">​</a></h3><blockquote><ul><li>特性:<br><strong>可见性</strong> 修饰的变量被修改时，其他线程能立刻可见(因为每次都是从内存获取，而不是查询线程缓存)<br><strong>顺序性</strong> 读写操作都是按顺序执行的，不会指令重排序</li><li>场景:<br><strong>控制标识位</strong> 控制多个线程之间的状态如等待、停止等<br><strong>双重检查锁定模式</strong> 多线程环境下实现延迟单例模式</li></ul></blockquote><h3 id="final" tabindex="-1">final <a class="header-anchor" href="#final" aria-label="Permalink to &quot;final&quot;">​</a></h3><blockquote><p><strong>final修饰的对象</strong> 对象的引用就不能被修改<br><strong>final修饰list</strong> list不能被重新赋值，即引用不能被修改，但是它里面的元素可以随意修改</p></blockquote><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><h3 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to &quot;List&quot;">​</a></h3><blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// list分片</span></span>
<span class="line"><span style="color:#A6ACCD;"> Lists</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">partition</span></span></code></pre></div><h4 id="arraylist" tabindex="-1">ArrayList <a class="header-anchor" href="#arraylist" aria-label="Permalink to &quot;ArrayList&quot;">​</a></h4><p>原理: 数组</p><p>特点: 线程不安全</p><h4 id="linkedlist" tabindex="-1">LinkedList <a class="header-anchor" href="#linkedlist" aria-label="Permalink to &quot;LinkedList&quot;">​</a></h4><p>原理: 链表</p><p>特点: 线程不安全</p><h4 id="vector" tabindex="-1">Vector <a class="header-anchor" href="#vector" aria-label="Permalink to &quot;Vector&quot;">​</a></h4><p>原理:</p><p>特点: 线程安全</p></blockquote><h3 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h3><blockquote><h4 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to &quot;HashMap&quot;">​</a></h4><blockquote><p>描述:</p><p>特点: 线程不安全</p><p>缺点:</p><blockquote><p>元素覆盖，两线程同时插入相同桶中，导致一个元素被另一个元素覆盖<br> 无限循环，一个线程在修改，另一个线程在遍历，可能遍历线程会无限循环</p></blockquote><p>场景:</p><blockquote><p>只能在单线程使用，多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p></blockquote><p>底层:</p><ul><li>节点类型:<br> jdk1.6-1.7 位桶(数组)+链表<br> jdk1.8 位桶(数组)+链表+红黑树 （链表长度达到8，链表转为红黑树）</li><li>把key通过hashCode()生成哈希值<br> 哈希冲突，多个键计算出相同的哈希值，则会把它们以链表的形式存储在数组同一位置，然后遍历链表查找特定键值对，链表长度超过8且hashMap容量超过64会将链表转为红黑树</li></ul><p>扩展:<br> 二叉树</p><blockquote><p>红黑树 自平衡二叉搜索树 时间复杂度O(log n)</p><p><img src="`+l+'" alt="img"></p><p><img src="'+o+`" alt="image-20221020153848095"></p></blockquote></blockquote><h4 id="concurrenthashmap" tabindex="-1">ConcurrentHashMap <a class="header-anchor" href="#concurrenthashmap" aria-label="Permalink to &quot;ConcurrentHashMap&quot;">​</a></h4><blockquote><p>描述: 一个支持高并发更新与查询的哈希表(基于HashMap)</p><p>特点: 线程安全</p><p>场景:</p><blockquote><p>多线程高并发场景<br> ConcurrentHashMap是J.U.C包里面提供的一个线程安全并且高效的HashMap，所以ConcurrentHashMap在并发编程的场景中使用的频率比较高。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 常用方法 基本跟hashMap一样</span></span>
<span class="line"><span style="color:#A6ACCD;">  map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">putIfAbsent</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">value1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span></code></pre></div></blockquote><p>底层:</p><ul><li>JDK1.7节点类型:​Segment数组(内部包含HashEntry数组) <ul><li>​ConcurrnetHashMap 由很多个 Segment 组合，Segment个数初始化后不能改变(默认16个)，每个Segment是类似HashMap结构，每个HashMap内部可以扩容</li><li>​分段锁:锁分离技术，减少锁的粒度，Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，<code>tryLock() 获取锁</code>，获取不到使用 scanAndLockForPut 方法继续获取</li><li>hash冲突解决方式 开放地址法</li></ul></li></ul><p><img src="`+t+`" alt="图片.png"></p><ul><li>JDK1.8节点类型:数组+链表/红黑树+CAS <ul><li>CAS核心算法:执行函数:CAS(V，E，N) <ol><li>V表示准备要被更新的变量 （内存的值）</li><li>E表示我们提供的 期望的值 （期望的原值）</li><li>N表示新值 ，准备更新V的值 （新值） HashEntry对象组成的链表长度<code>超过8时，或数组长度小于64 就会扩容</code>，否则链表转换为红黑树，提升性能。底层变更为数组＋链表＋红黑树</li></ol></li><li>hash冲突解决方式 链表/红黑树</li></ul></li></ul></blockquote></blockquote><h3 id="queue" tabindex="-1">Queue <a class="header-anchor" href="#queue" aria-label="Permalink to &quot;Queue&quot;">​</a></h3><blockquote><p>描述:<br> 特点: 元素按照插入顺序排列，先进先出<br> 底层:<br> 场景:</p><blockquote><p>适用于按照特定顺序处理元素的场景，例如任务调度、消息传递等</p></blockquote><h4 id="arrayblockingqueue" tabindex="-1">ArrayBlockingQueue <a class="header-anchor" href="#arrayblockingqueue" aria-label="Permalink to &quot;ArrayBlockingQueue&quot;">​</a></h4><blockquote><p>描述: 有界阻塞队列<br> 特点: 线程安全<br> 底层:</p><blockquote><p>内部是定长数组，初始化时确定大小，无法修改<br> 使用可重入锁(ReentrantLock)保证线程安全</p></blockquote></blockquote><h4 id="concurrentlinkedqueue" tabindex="-1">ConcurrentLinkedQueue <a class="header-anchor" href="#concurrentlinkedqueue" aria-label="Permalink to &quot;ConcurrentLinkedQueue&quot;">​</a></h4><blockquote><p>描述: 链接节点并发队列<br> 特点: 线程安全 可被多个线程同时访问修改<br> 底层:<br> 场景: 适合高并发环境队列操作</p></blockquote><h4 id="delayqueue" tabindex="-1">DelayQueue <a class="header-anchor" href="#delayqueue" aria-label="Permalink to &quot;DelayQueue&quot;">​</a></h4><blockquote><p>描述: 延时无界阻塞队列<br> 特点:</p><blockquote><p>线程安全 只有延时期满才能获取元素</p></blockquote><p>底层:<br> 场景:</p><blockquote><p>缓存系统 定时任务调度系统</p></blockquote></blockquote><h4 id="linkedblockingqueue" tabindex="-1">LinkedBlockingQueue <a class="header-anchor" href="#linkedblockingqueue" aria-label="Permalink to &quot;LinkedBlockingQueue&quot;">​</a></h4><blockquote><p>描述: 链表双向阻塞队列<br> 特点:</p><blockquote><p>线程安全<br> 队列大小可选，默认是 Integer.MAX_VALUE,内部采用容量可调的数组或链表存储元素，当队列满时，会阻塞插入操作，当队列空时，会阻塞取出操作;LinkedBlockingQueue的存储容量不受限制，但是在实际使用时，<strong>应根据实际场景进行合理的容量设置</strong>，避免内存不足的情况<br> 支持公平性策略，即按照线程请求的顺序来处理队列中的元素 提供了多种构造函数和一些方法，如 put、take、offer、poll 等，以便于控制队列的插入和删除行为</p></blockquote><p>底层: 链表 场景:</p><blockquote><p>LinkedBlockingQueue 不应该用于实现生产者-消费者模式的任务处理系统，因为它的容量是有限的，当队列已满时，生产者线程会被阻塞，导致整个系统的性能下降。对于这种情况，更适合使用无界队列，例如 ArrayBlockingQueue。</p></blockquote></blockquote></blockquote><blockquote><h4 id="linkedtransferqueue" tabindex="-1">LinkedTransferQueue <a class="header-anchor" href="#linkedtransferqueue" aria-label="Permalink to &quot;LinkedTransferQueue&quot;">​</a></h4><blockquote><p>描述:</p><blockquote><p>链表阻塞队列 功能和LinkedBlockingQueue类似，更丰富</p></blockquote><p>特点:</p></blockquote><h4 id="priorityqueue" tabindex="-1">PriorityQueue <a class="header-anchor" href="#priorityqueue" aria-label="Permalink to &quot;PriorityQueue&quot;">​</a></h4><blockquote><p>描述:无界队列 特点:</p><blockquote><ul><li>线程不安全</li><li>无序，默认自然排序，可自定义comparator 底层:数组</li></ul></blockquote></blockquote><h4 id="priorityblockingqueue" tabindex="-1">PriorityBlockingQueue <a class="header-anchor" href="#priorityblockingqueue" aria-label="Permalink to &quot;PriorityBlockingQueue&quot;">​</a></h4><blockquote><p>描述: 无界阻塞队列<br> 特点:</p><blockquote><p>线程安全<br> 无序，默认自然排序，可自定义comparator<br> 队列空获取元素会阻塞线程直到有数据，队列满了插入元素也会阻塞线程直到有空闲\\</p></blockquote><p>底层:二叉堆</p></blockquote><h4 id="synchronousqueue" tabindex="-1">SynchronousQueue <a class="header-anchor" href="#synchronousqueue" aria-label="Permalink to &quot;SynchronousQueue&quot;">​</a></h4><blockquote><p>描述: 不存储元素的阻塞队列<br> 特点:</p><blockquote><p>没有容量、不存储元素<br> 每个插入操作必须等待一个对应的删除操作<br> 公平(即按照线程的到达顺序来进行处理)、非公平访问策略(默认)</p></blockquote><p>底层:<br> 场景: 传递性场景 生产者消费者场景 吞吐量较高</p></blockquote></blockquote><h3 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h3><p><a href="https://juejin.cn/post/7156200349685317663" target="_blank" rel="noreferrer">https://juejin.cn/post/7156200349685317663</a></p><h2 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h2><h3 id="retryable" tabindex="-1">@Retryable <a class="header-anchor" href="#retryable" aria-label="Permalink to &quot;@Retryable&quot;">​</a></h3><p>方法异常重试</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Retryable</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">value</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Exception</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">maxAttempts</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">backoff</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Backoff</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">delay</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">multiplier</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">ReqVo</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> add</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><h3 id="进程和线程关系" tabindex="-1">进程和线程关系 <a class="header-anchor" href="#进程和线程关系" aria-label="Permalink to &quot;进程和线程关系&quot;">​</a></h3><p>进程 静态的，可以启动多个，比如qq.exe，一个程序进入内存，会产生一个主线程 线程 动态的，一个alu只能执行一个</p><p>alu 算术逻辑单元 计算机数学大脑 负责运算的组件</p><h3 id="线程状态" tabindex="-1">线程状态 <a class="header-anchor" href="#线程状态" aria-label="Permalink to &quot;线程状态&quot;">​</a></h3><p><img src="`+p+`" alt="img"></p><h3 id="线程创建方式" tabindex="-1">线程创建方式 <a class="header-anchor" href="#线程创建方式" aria-label="Permalink to &quot;线程创建方式&quot;">​</a></h3><h4 id="runnable" tabindex="-1">Runnable <a class="header-anchor" href="#runnable" aria-label="Permalink to &quot;Runnable&quot;">​</a></h4><h4 id="thread" tabindex="-1">Thread <a class="header-anchor" href="#thread" aria-label="Permalink to &quot;Thread&quot;">​</a></h4><h4 id="callable" tabindex="-1">Callable <a class="header-anchor" href="#callable" aria-label="Permalink to &quot;Callable&quot;">​</a></h4><h4 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h4><blockquote><p>不推荐使用Executors创建线程<br> 推荐使用new ThreadPoolExecutor()的方式,根据服务器核心数自定义线程参数</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@Bean(&quot;myExecutor&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    public ExecutorService myExecutor() {</span></span>
<span class="line"><span style="color:#A6ACCD;">        ExecutorService ex = new ThreadPoolExecutor(</span></span>
<span class="line"><span style="color:#A6ACCD;">                2,</span></span>
<span class="line"><span style="color:#A6ACCD;">                2,</span></span>
<span class="line"><span style="color:#A6ACCD;">                0L,</span></span>
<span class="line"><span style="color:#A6ACCD;">                TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#A6ACCD;">                new LinkedBlockingQueue&lt;&gt;(100),// 指定任务数量</span></span>
<span class="line"><span style="color:#A6ACCD;">                new CustomThreadFactory(),</span></span>
<span class="line"><span style="color:#A6ACCD;">                (r, e) -&gt; log.error(&quot;异常&quot;));</span></span>
<span class="line"><span style="color:#A6ACCD;">        return ex;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span></code></pre></div></blockquote><h3 id="线程池-1" tabindex="-1">线程池 <a class="header-anchor" href="#线程池-1" aria-label="Permalink to &quot;线程池&quot;">​</a></h3><h4 id="线程池工作流程" tabindex="-1">线程池工作流程 <a class="header-anchor" href="#线程池工作流程" aria-label="Permalink to &quot;线程池工作流程&quot;">​</a></h4><p><img src="`+r+`" alt="img"></p><h4 id="线程池类型" tabindex="-1">线程池类型 <a class="header-anchor" href="#线程池类型" aria-label="Permalink to &quot;线程池类型&quot;">​</a></h4><h5 id="executors-newfixedthreadpool" tabindex="-1">Executors.newFixedThreadPool <a class="header-anchor" href="#executors-newfixedthreadpool" aria-label="Permalink to &quot;Executors.newFixedThreadPool&quot;">​</a></h5><blockquote><p>描述:</p><blockquote><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p></blockquote><p>特点:</p><blockquote><p>是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，<strong>没任务时，不会释放工作线程，占用系统资源</strong></p></blockquote><p>底层:</p><blockquote><p>nThreads参数表示线程池中最多运行两个线程<br> LinkedBlockingQueue线程池任务队列，把任务放这等待执行，用到了不设容量的链表阻塞队列，容易导致内存不足</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ExecutorService</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newFixedThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> nThreads</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ThreadFactory</span><span style="color:#A6ACCD;"> threadFactory</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ThreadPoolExecutor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">nThreads</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> nThreads</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">                                      </span><span style="color:#F78C6C;">0L</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MILLISECONDS</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">                                      </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">LinkedBlockingQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Runnable</span><span style="color:#89DDFF;">&gt;(),</span></span>
<span class="line"><span style="color:#A6ACCD;">                                      threadFactory</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote></blockquote><h5 id="executors-newcachedthreadpool" tabindex="-1">Executors.newCachedThreadPool <a class="header-anchor" href="#executors-newcachedthreadpool" aria-label="Permalink to &quot;Executors.newCachedThreadPool&quot;">​</a></h5><blockquote><p>描述: 一个可缓存的线程池</p><p>特点:</p><blockquote><p>线程池中的<strong>线程数是根据任务的数量动态调整的</strong>，没任务时会释放线程，有任务时才创建工作线程\\</p><ol><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程，同时创建大量线程时，有可能造成系统瘫痪</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止</li></ol></blockquote><p>底层:</p><blockquote><p>SynchronousQueue任务队列，使用没有存储能力的阻塞队列，主要目的是为了实现一个具有动态调整线程数的线程池<br> 如果没有空闲线程可用，SynchronousQueue 的特性决定了任务必须等待一个空闲线程。在这种情况下，线程池会创建一个新的线程来处理任务。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ExecutorService</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newCachedThreadPool</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ThreadPoolExecutor</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MAX_VALUE</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">                                      </span><span style="color:#F78C6C;">60L</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">                                      </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">SynchronousQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Runnable</span><span style="color:#89DDFF;">&gt;());</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote></blockquote><h5 id="executors-newsinglethreadexecutor" tabindex="-1">Executors.newSingleThreadExecutor <a class="header-anchor" href="#executors-newsinglethreadexecutor" aria-label="Permalink to &quot;Executors.newSingleThreadExecutor&quot;">​</a></h5><blockquote><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证<strong>顺序地执行</strong>各个任务，并且在任意给定的时间不会有多个线程是活动的 。 PS:至始至终都只有一个线程，那用线程池干嘛呢？直接创建一个新的线程不就可以了嘛，不懂！</p></blockquote><h5 id="executors-newschedulethreadpool" tabindex="-1">Executors.newScheduleThreadPool <a class="header-anchor" href="#executors-newschedulethreadpool" aria-label="Permalink to &quot;Executors.newScheduleThreadPool&quot;">​</a></h5><blockquote><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。</p></blockquote><h3 id="相关" tabindex="-1">相关 <a class="header-anchor" href="#相关" aria-label="Permalink to &quot;相关&quot;">​</a></h3><h4 id="submit-、execute-区别" tabindex="-1">submit()、execute()区别 <a class="header-anchor" href="#submit-、execute-区别" aria-label="Permalink to &quot;submit()、execute()区别&quot;">​</a></h4><blockquote><p>JDK5往后，任务分两类:一类是实现了Runnable接口的类，一类是实现了Callable接口的类。两者都可以被ExecutorService执行，<br> 它们的区别是:<br> execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口<br> submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口</p></blockquote><h4 id="invokeall-、invokeany-区别" tabindex="-1">invokeAll()、invokeAny()区别 <a class="header-anchor" href="#invokeall-、invokeany-区别" aria-label="Permalink to &quot;invokeAll()、invokeAny()区别&quot;">​</a></h4><blockquote><p>invokeAll触发执行任务列表，返回的结果顺序也与任务在任务列表中的顺序一致.所有线程执行完任务后才返回结果。如果设置了超时时间，未超时完成则正常返回结果，如果超时未完成则报异常。<br> invokeAny将第一个得到的结果作为返回值，然后立刻终止所有的线程。如果设置了超时时间，未超时完成则正常返回结果，如果超时未完成则报超时异常。<br> 1、invallkeAll和invokeAny会直接造成主线程阻塞（需要设置超时时间）。等待所有任务执行完成后返回结果，主线程继续执行。<br> 2、submit不会造成主线程阻塞，在后面执行get方法的时候阻塞。超时时间在get里面设置。<br> 3、execute会新开启线程直接执行任务，不会阻塞主线程。但无返回结果。</p></blockquote><h4 id="cpu" tabindex="-1">cpu <a class="header-anchor" href="#cpu" aria-label="Permalink to &quot;cpu&quot;">​</a></h4><h5 id="cpu缓存一致性协议" tabindex="-1">cpu缓存一致性协议 <a class="header-anchor" href="#cpu缓存一致性协议" aria-label="Permalink to &quot;cpu缓存一致性协议&quot;">​</a></h5><blockquote><p>​ cpu负责运算，将运算结果输出到主内存，主内存读写速度不够，cpu在中间加了三级缓存，工业上实践得出，采用三级缓存性价比最好，缓存之间信息同步需要缓存一致性协议</p><p><img src="`+c+'" alt="img"></p><p><img src="'+i+'" alt="img"></p></blockquote><h5 id="cpu的伪共享" tabindex="-1">CPU的<em>伪共享</em> <a class="header-anchor" href="#cpu的伪共享" aria-label="Permalink to &quot;CPU的*伪共享*&quot;">​</a></h5><blockquote><p><strong>当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享</strong>。</p></blockquote><h5 id="cpu乱序执行" tabindex="-1">cpu乱序执行 <a class="header-anchor" href="#cpu乱序执行" aria-label="Permalink to &quot;cpu乱序执行&quot;">​</a></h5><p><img src="'+u+'" alt="img"></p><p>1、future类</p><p>2、thread.join() 需要等待线程执行完</p><h4 id="线程池无界队列引发的内存飙升" tabindex="-1">线程池无界队列引发的内存飙升 <a class="header-anchor" href="#线程池无界队列引发的内存飙升" aria-label="Permalink to &quot;线程池无界队列引发的内存飙升&quot;">​</a></h4><p><a href="https://juejin.cn/post/6844903769025544206" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903769025544206</a></p><h2 id="jvm" tabindex="-1">jvm <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;jvm&quot;">​</a></h2><h3 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h3><blockquote><p>Jdk包括了Jre和Jvm，Jre包括了Jvm</p><ul><li>Jdk是我们编写代码使用的开发工具包</li><li>Jre 是Java的运行时环境，他大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库</li><li>Jvm俗称Java虚拟机，他是java运行环境的一部分，它虚构出来的一台计算机，在通过在实际的计算机上仿真模拟各种计算机功能来实现Java应用程序</li></ul><p><img src="'+h+'" alt="image-20221027164521781"></p><p>jvm内部组成</p><p><img src="'+C+'" alt="在这里插入图片描述"></p></blockquote><h3 id="线程-1" tabindex="-1">线程 <a class="header-anchor" href="#线程-1" aria-label="Permalink to &quot;线程&quot;">​</a></h3><blockquote><p>类型:应用线程\\系统线程 或者 守护线程\\非守护线程<br> 系统线程:<br><strong>Compile Threads</strong>:运行时将字节码编译为本地代码所使用的线程<br><strong>GC Threads</strong>:包含所有和 GC 有关操作<br><strong>Periodic Task Thread</strong>:JVM 周期性任务调度的线程，主要包含 JVM 内部的采样分析<br><strong>Singal Dispatcher Thread</strong>:处理 OS 发来的信号(OS是操作系统)<br><strong>VM Thread</strong>:某些操作需要等待 JVM 到达 <strong>安全点（Safe Point）</strong> ，即堆区没有变化。比如:GC 操作、线程 Dump、线程挂起 这些操作都在 VM Thread 中进行。</p></blockquote><h3 id="类加载器" tabindex="-1">类加载器 <a class="header-anchor" href="#类加载器" aria-label="Permalink to &quot;类加载器&quot;">​</a></h3><blockquote><p>应用类加载器，加载我们classpath目录下的所有类文件<br> 扩展类加载器，加载标准 Java 类库扩展的类，就是你的jre目录下的/lib/ext目录下的所有类<br> 根类加载器（bootstrap classloader），扫描 BootClassPath 下的 标准 Java 类库的类加载器。标准 Java 类库限制了一些包路径的类，必须通过根类加载器加载。</p></blockquote><h3 id="类实例化" tabindex="-1">类实例化 <a class="header-anchor" href="#类实例化" aria-label="Permalink to &quot;类实例化&quot;">​</a></h3><blockquote><p>明确的实例化:</p><blockquote><p>明确调用<code>new</code>。<br> 调用<code>Class</code>或者<code>java.lang.reflect.Constructor</code>对象的<code>newInstance</code>方法。<br> 调用任何现有对象的<code>clone</code>。<br> 通过<code>java.io.ObjectInputStream.getObject()</code>反序列化。</p></blockquote><p>隐含的实例化:</p><blockquote><p>可能是保存命令行参数的<code>String</code>对象。<br> 对于Java虚拟机装载的每个类，都会暗中实例化一个Class对象来代表这个类型<br> 当Java虚拟机装载了在常量池中包含<code>CONSTANT_String_info</code>入口的类的时候，它会创建新的<code>String</code>对象来表示这些常量字符串。<br> 执行包含字符串连接操作符的表达式会产生新的对象。</p></blockquote></blockquote><h3 id="监控工具" tabindex="-1">监控工具 <a class="header-anchor" href="#监控工具" aria-label="Permalink to &quot;监控工具&quot;">​</a></h3><blockquote><p>Prometheus</p></blockquote><h3 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h3><h4 id="手动垃圾回收" tabindex="-1">手动垃圾回收 <a class="header-anchor" href="#手动垃圾回收" aria-label="Permalink to &quot;手动垃圾回收&quot;">​</a></h4><blockquote><p>代码执行 System.gc() jmap触发 jvmti( JVM Tool Interface)</p></blockquote><h4 id="system-gc" tabindex="-1">System.gc <a class="header-anchor" href="#system-gc" aria-label="Permalink to &quot;System.gc&quot;">​</a></h4><blockquote><p>危害:</p><blockquote><p>System.gc 其实是做一次 full gc，full gc 会暂停整个进程。如果进程经常被频繁暂停，就要注意超时、并发等问题<br> 通过 -XX:+DisableExplicitGC 禁掉 System.gc</p></blockquote><p>原理:</p><blockquote><p>Java 里面的 GC 有一个重要的线程 <strong>VMThread</strong>。在 jvm 里，这个线程会不断轮询它的队列，这个队列里主要是存一些 VM_operation 的动作，比如最常见的就是内存分配失败要求做 GC 操作的请求等，在对 gc 这些操作执行的时候会先将其他业务线程都进入到<strong>安全点</strong>，也就是这些线程从此不再执行任何字节码指令，只有当出了安全点的时候才让他们继续执行原来的指令，因此这其实就是我们说的 <strong>stop the world(STW)</strong>，整个进程相当于静止了。</p></blockquote></blockquote><h4 id="并行的-full-gc" tabindex="-1">并行的 Full GC <a class="header-anchor" href="#并行的-full-gc" aria-label="Permalink to &quot;并行的 Full GC&quot;">​</a></h4><blockquote><p>并行 Full GC 也同样会做 YGC 和 CMS GC，但是效率高就搞在 CMS GC 是走的 background 的，整个暂停的过程主要是 YGC、CMS_initMark、CMS_remark 几个阶段。<br> background 顾名思义是在后台做的，也就是可以不影响正常的业务线程跑，触发条件比如说 old 的内存占比超过多少的时候就可能触发一次 background 式的 cms gc，这个过程会经历 CMS GC 的所有阶段，该暂停的暂停，该并行的并行，效率相对来说还比较高，毕竟有和业务线程并行的 gc 阶段；<br> 而 foreground 则不然，它发生的场景比如业务线程请求分配内存，但是内存不够了，于是可能触发一次 cms gc，这个过程就必须是要等内存分配到了线程才能继续往下面走的，因此整个过程必须是STW的，因此 CMS GC 整个过程都是暂停应用的，但是为了提高效率，它并不是每个阶段都会走的，只走其中一些阶段，这些省下来的阶段主要是并行阶段。</p></blockquote><h4 id="防止长时间gc" tabindex="-1">防止长时间GC <a class="header-anchor" href="#防止长时间gc" aria-label="Permalink to &quot;防止长时间GC&quot;">​</a></h4><blockquote><p>排查顺序</p><blockquote><p><img src="'+d+'" alt="image-20220801164155012"></p></blockquote><p>参数调优 (参考 『吞吐量』、『停顿时间』和『垃圾回收频率』)</p><blockquote><p>内存策略</p><blockquote><p>-Xmx:设置堆的最大值<br> -Xms:设置堆的初始值<br> -Xmn:表示年轻代的大小<br> -XX:SurvivorRatio:伊甸区和幸存区的比例等等<br> IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡<br> 内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些</p></blockquote><p>垃圾回收器、垃圾回收调优参数</p><blockquote><p>-XX:+UseG1GC:指定 JVM 使用的垃圾回收器为 G1<br> -XX:MaxGCPauseMillis:设置目标停顿时间<br> -XX:InitiatingHeapOccupancyPercent:当整个堆内存使用达到一定比例，全局并发标记阶段 就会被启动等等</p></blockquote><p>命令</p><blockquote><p>jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行<br> jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况<br> jinfo命令来查看和调整Java进程的「运行参数」<br> jmap命令来查看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析<br> jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题<br> Arthas（阿里开源的诊断工具）<br><img src="'+A+`" alt="image-20220801170004517"></p></blockquote></blockquote><p>Thread.sleep(0)<br> 可数循环:for (int i=0...)<br> 不可数循环:for(long i=0...)</p></blockquote><h3 id="oom" tabindex="-1">oom <a class="header-anchor" href="#oom" aria-label="Permalink to &quot;oom&quot;">​</a></h3><blockquote><p>内存溢出场景</p><blockquote><p>1、对象生命周期过长<br> 2、无限递归<br> 3、大数据集合<br> 4、jvm配置不当</p></blockquote><p>内存泄漏</p><blockquote><p>内存泄漏 表示就是我们申请了内存，但是该内存一直无法释放； 内存泄漏会导致<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">内存溢出</a>问题: 申请内存时，发现申请内存不足，就会报错 ；</p></blockquote></blockquote><h3 id="参考文档-1" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档-1" aria-label="Permalink to &quot;参考文档&quot;">​</a></h3><p><a href="https://blog.csdn.net/weixin_39633054/article/details/111646187" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_39633054/article/details/111646187</a><a href="https://juejin.cn/post/7139741080597037063#comment" target="_blank" rel="noreferrer">https://juejin.cn/post/7139741080597037063#comment</a><a href="https://juejin.cn/post/7034669867286396958" target="_blank" rel="noreferrer">https://juejin.cn/post/7034669867286396958</a></p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><h3 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h3><h4 id="创建过程" tabindex="-1">创建过程 <a class="header-anchor" href="#创建过程" aria-label="Permalink to &quot;创建过程&quot;">​</a></h4><blockquote><p>1、创建实例<br> 2、构造器私有化（外部不能使用构造器创建对象）<br> 3、返回实例的方法</p></blockquote><h4 id="饿汉式" tabindex="-1">饿汉式 <a class="header-anchor" href="#饿汉式" aria-label="Permalink to &quot;饿汉式&quot;">​</a></h4><blockquote><p>线程安全，调用效率高，但是不能延时加载</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Tong</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> Tong</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> instance</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote><h4 id="懒汉式" tabindex="-1">懒汉式 <a class="header-anchor" href="#懒汉式" aria-label="Permalink to &quot;懒汉式&quot;">​</a></h4><blockquote><p>线程安全，调用效率不高，但是能延时加载</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> tong</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">tong </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            tong</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> tong</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote><h4 id="双重检查" tabindex="-1">双重检查 <a class="header-anchor" href="#双重检查" aria-label="Permalink to &quot;双重检查&quot;">​</a></h4><blockquote><p>DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）</p><blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> tong</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">tong</span><span style="color:#89DDFF;">==null){</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Tong</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#A6ACCD;">              </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">tong</span><span style="color:#89DDFF;">==null){</span></span>
<span class="line"><span style="color:#A6ACCD;">                  tong</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">              </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> tong</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote><p>上面的也不好，发生cpu指令重排序的话，还是会有点问题，但是发生概率不怎么高<br> volatile版本</p><blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Foo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Helper</span><span style="color:#A6ACCD;"> helper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Foo</span><span style="color:#89DDFF;">(){}</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Helper</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getHelper</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">helper </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(this)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">helper </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">                 </span><span style="color:#676E95;font-style:italic;">//（jvm new对象的过程 申请内存-&gt;变量初始化-&gt;赋值给helper）</span></span>
<span class="line"><span style="color:#A6ACCD;">                    helper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Helper</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;font-style:italic;">//指令重排序 上面的顺序乱了，可能会导致对象值不准，volatile可以防止指令重排序</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> helper</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote></blockquote><h4 id="静态内部类实现模式" tabindex="-1">静态内部类实现模式 <a class="header-anchor" href="#静态内部类实现模式" aria-label="Permalink to &quot;静态内部类实现模式&quot;">​</a></h4><blockquote><p>线程安全，调用效率高，可以延时加载</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TongInstance</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> tongInstance</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Tong</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Tong</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> TongInstance</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">tongInstance</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote><h3 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to &quot;工厂模式&quot;">​</a></h3><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><h3 id="责任链模式" tabindex="-1">责任链模式 <a class="header-anchor" href="#责任链模式" aria-label="Permalink to &quot;责任链模式&quot;">​</a></h3><p>创建型模式(5种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式(7种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式(11种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="spring" tabindex="-1">spring <a class="header-anchor" href="#spring" aria-label="Permalink to &quot;spring&quot;">​</a></h2><blockquote><h3 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h3><h4 id="acid特性" tabindex="-1">ACID特性 <a class="header-anchor" href="#acid特性" aria-label="Permalink to &quot;ACID特性&quot;">​</a></h4><blockquote><h5 id="原子性-atomicity" tabindex="-1">原子性 (Atomicity） <a class="header-anchor" href="#原子性-atomicity" aria-label="Permalink to &quot;原子性 (Atomicity）&quot;">​</a></h5><blockquote><p>一个事务内涉及到分布式多个节点的所有操作要么一起成功，要么一起失败。</p></blockquote><h5 id="一致性-consistency" tabindex="-1">一致性 (Consistency) <a class="header-anchor" href="#一致性-consistency" aria-label="Permalink to &quot;一致性 (Consistency)&quot;">​</a></h5><blockquote><p>(事务结果要和真实结果一致)<br> 跨节点场景下也不能出现中间状态。上面转账的例子中，A和B的数据可能不在一个节点上，转账的全程依然要保持A+B都为100块，不存在其他的结果。</p></blockquote><h5 id="隔离性-isolation" tabindex="-1">隔离性（Isolation） <a class="header-anchor" href="#隔离性-isolation" aria-label="Permalink to &quot;隔离性（Isolation）&quot;">​</a></h5><blockquote><p>多个事务并发执行时，互相隔离，互不干扰</p></blockquote><h5 id="持久性-durability" tabindex="-1">持久性 (Durability) <a class="header-anchor" href="#持久性-durability" aria-label="Permalink to &quot;持久性 (Durability)&quot;">​</a></h5><blockquote><p>事务提交完成后的数据不仅要在当前节点保存，还应该在分布式场景下有备份，具备高可用性。</p></blockquote></blockquote><h4 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to &quot;隔离级别&quot;">​</a></h4><blockquote><p>todo</p></blockquote><h4 id="参考文档-2" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档-2" aria-label="Permalink to &quot;参考文档&quot;">​</a></h4><p><a href="https://juejin.cn/post/7237439385909592122#heading-11" target="_blank" rel="noreferrer">https://juejin.cn/post/7237439385909592122#heading-11</a></p></blockquote><h2 id="spingcloud" tabindex="-1">spingcloud <a class="header-anchor" href="#spingcloud" aria-label="Permalink to &quot;spingcloud&quot;">​</a></h2><p><img src="`+b+'" alt="image"><img src="'+y+`" alt="image"></p><p>参考资料</p><p><a href="https://blog.csdn.net/mkmkmkhh/article/details/101996991?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noreferrer">https://blog.csdn.net/mkmkmkhh/article/details/101996991?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&amp;spm=1001.2101.3001.4242</a></p><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><h4 id="spring-cloud-security" tabindex="-1">Spring Cloud Security <a class="header-anchor" href="#spring-cloud-security" aria-label="Permalink to &quot;Spring Cloud Security&quot;">​</a></h4><h4 id="eureka-停更" tabindex="-1">Eureka(停更) <a class="header-anchor" href="#eureka-停更" aria-label="Permalink to &quot;Eureka(停更)&quot;">​</a></h4><p>服务注册中心</p><h4 id="hystrix" tabindex="-1">Hystrix <a class="header-anchor" href="#hystrix" aria-label="Permalink to &quot;Hystrix&quot;">​</a></h4><p>1,服务降级 比如当某个服务繁忙,不能让客户端的请求一直等待,应该立刻返回给客户端一个备选方案 2,服务熔断 当某个服务出现问题,卡死了,不能让用户一直等待,需要关闭所有对此服务的访问然后调用服务降级 3,服务限流 限流,比如秒杀场景,不能访问用户瞬间都访问服务器,限制一次只可以有多少请求</p><h4 id="zuul" tabindex="-1">Zuul <a class="header-anchor" href="#zuul" aria-label="Permalink to &quot;Zuul&quot;">​</a></h4><h4 id="ribbon" tabindex="-1">Ribbon <a class="header-anchor" href="#ribbon" aria-label="Permalink to &quot;Ribbon&quot;">​</a></h4><p>可以用LoadBalance代替</p><h4 id="feign" tabindex="-1">Feign <a class="header-anchor" href="#feign" aria-label="Permalink to &quot;Feign&quot;">​</a></h4><p>现在用openFeign OpenFeign默认使用ribbon做负载均衡，超时时间是由ribbon控制</p><h4 id="spring-cloud-alibaba" tabindex="-1">spring Cloud Alibaba <a class="header-anchor" href="#spring-cloud-alibaba" aria-label="Permalink to &quot;spring Cloud Alibaba&quot;">​</a></h4><p>包含nacos</p><h4 id="spring-cloud-zookeeper" tabindex="-1">Spring Cloud Zookeeper <a class="header-anchor" href="#spring-cloud-zookeeper" aria-label="Permalink to &quot;Spring Cloud Zookeeper&quot;">​</a></h4><h4 id="spring-cloud-config" tabindex="-1">Spring Cloud Config <a class="header-anchor" href="#spring-cloud-config" aria-label="Permalink to &quot;Spring Cloud Config&quot;">​</a></h4><h4 id="spring-cloud-bus" tabindex="-1">Spring Cloud Bus <a class="header-anchor" href="#spring-cloud-bus" aria-label="Permalink to &quot;Spring Cloud Bus&quot;">​</a></h4><h4 id="archaius" tabindex="-1">Archaius <a class="header-anchor" href="#archaius" aria-label="Permalink to &quot;Archaius&quot;">​</a></h4><h4 id="consul" tabindex="-1">Consul <a class="header-anchor" href="#consul" aria-label="Permalink to &quot;Consul&quot;">​</a></h4><h4 id="spring-cloud-for-cloud-foundry" tabindex="-1">Spring Cloud for Cloud Foundry <a class="header-anchor" href="#spring-cloud-for-cloud-foundry" aria-label="Permalink to &quot;Spring Cloud for Cloud Foundry&quot;">​</a></h4><h4 id="spring-cloud-sleuth" tabindex="-1">Spring Cloud Sleuth <a class="header-anchor" href="#spring-cloud-sleuth" aria-label="Permalink to &quot;Spring Cloud Sleuth&quot;">​</a></h4><h4 id="spring-cloud-data-flow" tabindex="-1">Spring Cloud Data Flow <a class="header-anchor" href="#spring-cloud-data-flow" aria-label="Permalink to &quot;Spring Cloud Data Flow&quot;">​</a></h4><h4 id="spring-cloud-stream" tabindex="-1">Spring Cloud Stream <a class="header-anchor" href="#spring-cloud-stream" aria-label="Permalink to &quot;Spring Cloud Stream&quot;">​</a></h4><h4 id="spring-cloud-cli" tabindex="-1">Spring Cloud CLI <a class="header-anchor" href="#spring-cloud-cli" aria-label="Permalink to &quot;Spring Cloud CLI&quot;">​</a></h4><h4 id="turbine" tabindex="-1">Turbine <a class="header-anchor" href="#turbine" aria-label="Permalink to &quot;Turbine&quot;">​</a></h4><h4 id="spring-cloud-task" tabindex="-1">Spring Cloud Task <a class="header-anchor" href="#spring-cloud-task" aria-label="Permalink to &quot;Spring Cloud Task&quot;">​</a></h4><h4 id="spring-cloud-connectors" tabindex="-1">Spring Cloud Connectors <a class="header-anchor" href="#spring-cloud-connectors" aria-label="Permalink to &quot;Spring Cloud Connectors&quot;">​</a></h4><h4 id="spring-cloud-cluster" tabindex="-1">Spring Cloud Cluster <a class="header-anchor" href="#spring-cloud-cluster" aria-label="Permalink to &quot;Spring Cloud Cluster&quot;">​</a></h4><h4 id="spring-cloud-starters" tabindex="-1">Spring Cloud Starters <a class="header-anchor" href="#spring-cloud-starters" aria-label="Permalink to &quot;Spring Cloud Starters&quot;">​</a></h4><h3 id="事务传播机制" tabindex="-1">事务传播机制 <a class="header-anchor" href="#事务传播机制" aria-label="Permalink to &quot;事务传播机制&quot;">​</a></h3><h2 id="maven" tabindex="-1">maven <a class="header-anchor" href="#maven" aria-label="Permalink to &quot;maven&quot;">​</a></h2><h3 id="清理仓库文件脚本" tabindex="-1">清理仓库文件脚本 <a class="header-anchor" href="#清理仓库文件脚本" aria-label="Permalink to &quot;清理仓库文件脚本&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">set REPOSITORY_PATH=E:mymavenmyLocalRepository</span></span>
<span class="line"><span style="color:#A6ACCD;">rem 正在搜索...</span></span>
<span class="line"><span style="color:#A6ACCD;">for /f &quot;delims=&quot; %%i in (&#39;dir /b /s &quot;%REPOSITORY_PATH%*lastUpdated*&quot;&#39;) do (</span></span>
<span class="line"><span style="color:#A6ACCD;">    del /s /q %%i</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">rem 搜索完毕</span></span>
<span class="line"><span style="color:#A6ACCD;">pause</span></span></code></pre></div><h2 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h2><h3 id="sharding-jdbc" tabindex="-1">Sharding-Jdbc <a class="header-anchor" href="#sharding-jdbc" aria-label="Permalink to &quot;Sharding-Jdbc&quot;">​</a></h3><h4 id="基础-1" tabindex="-1">基础 <a class="header-anchor" href="#基础-1" aria-label="Permalink to &quot;基础&quot;">​</a></h4><blockquote><p>sharding-jdbc是ShardingSphere（分布式数据库生态系统）的一个组成部分，是轻量级java框架</p><h5 id="绑定表" tabindex="-1">绑定表 <a class="header-anchor" href="#绑定表" aria-label="Permalink to &quot;绑定表&quot;">​</a></h5><blockquote><p>分片规则一致的主表和子表</p></blockquote><h5 id="广播表" tabindex="-1">广播表 <a class="header-anchor" href="#广播表" aria-label="Permalink to &quot;广播表&quot;">​</a></h5><blockquote><p>表结构和数据在数据库中都一致，适用数据量不大但需要与海量数据表进行关联查询的场景，例如字典表</p></blockquote></blockquote><h4 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h4><blockquote><p>数据分片，分布式事务，读写分离等，其中使用最多的就是数据分片</p></blockquote><h4 id="数据分片" tabindex="-1">数据分片 <a class="header-anchor" href="#数据分片" aria-label="Permalink to &quot;数据分片&quot;">​</a></h4><blockquote><h5 id="分片键" tabindex="-1">分片键 <a class="header-anchor" href="#分片键" aria-label="Permalink to &quot;分片键&quot;">​</a></h5><blockquote><p>用于分片的字段，用于拆分数据库或表的字段</p></blockquote><h5 id="分片算法" tabindex="-1">分片算法 <a class="header-anchor" href="#分片算法" aria-label="Permalink to &quot;分片算法&quot;">​</a></h5><p>​ 1、精确分片算法</p><blockquote><p>对应PreciseShardingAlgorithm，用于处理使用<strong>单一键</strong>作为分片键的=与IN进行分片的场景。需要配合StandardShardingStrategy使用</p></blockquote><p>​ 2、范围分片算法</p><blockquote><p>对应RangeShardingAlgorithm，用于处理使用<strong>单一键</strong>作为分片键的BETWEEN AND、&gt;、&lt;、&gt;=、&lt;=进行分片的场景。需要配合StandardShardingStrategy使用。</p></blockquote><p>​ 3、复合分片算法</p><blockquote><p>对应ComplexKeysShardingAlgorithm，用于处理使用<strong>多键</strong>作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合ComplexShardingStrategy使用。</p></blockquote><p>​ 4、Hint分片算法</p><blockquote><p>对应HintShardingAlgorithm，用于处理使用Hint行分片的场景。需要配合HintShardingStrategy使用</p></blockquote><h5 id="分片策略-分片键-分片算法" tabindex="-1">分片策略(分片键+分片算法) <a class="header-anchor" href="#分片策略-分片键-分片算法" aria-label="Permalink to &quot;分片策略(分片键+分片算法)&quot;">​</a></h5><p>1、标准分片策略</p><blockquote><p>对应StandardShardingStrategy。提供对SQL语句中的=, &gt;, &lt;, &gt;=, &lt;=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持<strong>单分片键</strong>，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND, &gt;, &lt;, &gt;=, &lt;=分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。</p></blockquote><p>2、复合分片策略</p><blockquote><p>对应ComplexShardingStrategy。复合分片策略。提供对SQL语句中的=, &gt;, &lt;, &gt;=, &lt;=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于<strong>多分片键</strong>之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</p></blockquote><p>3、行表达式分片策略</p><blockquote><p>对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持<strong>单分片键</strong>。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$-&gt;{u_id % 8} 表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7。</p></blockquote><p>4、Hint分片策略</p><blockquote><p>对应HintShardingStrategy。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略</p></blockquote><p>5、不分片策略</p><blockquote><p>对应NoneShardingStrategy。不分片的策略。</p></blockquote></blockquote><h2 id="分布式" tabindex="-1">分布式 <a class="header-anchor" href="#分布式" aria-label="Permalink to &quot;分布式&quot;">​</a></h2><h3 id="分布式追踪系统" tabindex="-1">分布式追踪系统 <a class="header-anchor" href="#分布式追踪系统" aria-label="Permalink to &quot;分布式追踪系统&quot;">​</a></h3><blockquote><p><strong>自定义日志跟踪系统</strong></p><blockquote><p>手动生成taceId放请求头里在各个服务中使用</p></blockquote><p><strong>skywalking</strong></p><blockquote><p>开源的应用性能监控和分析系统</p></blockquote><p>Zipkin</p><blockquote><p>开源，提供了收集、存储和展示跨多个服务的请求追踪数据的功能。使用Zipkin可以追踪请求在分布式系统中的传输路径，并对请求的性能进行可视化展示</p></blockquote><p>Jaeger</p><blockquote><p>开源的端到端的分布式追踪系统</p></blockquote><p>OpenTracing</p><p>Dapper</p><blockquote><p>Google开发的</p></blockquote><p>HTrace</p><blockquote><p>在Apache Software Foundation下开源</p></blockquote><p>X-Trace</p></blockquote><h3 id="分布式锁" tabindex="-1">分布式锁 <a class="header-anchor" href="#分布式锁" aria-label="Permalink to &quot;分布式锁&quot;">​</a></h3><blockquote><h4 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h4><blockquote><p>防止重复点击<br> 控制任务调度 （某定时任务某时刻只能执行一次这种）</p></blockquote><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><blockquote><p>setIfAbsent</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> lockKey </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> RedisConstant</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">LOCK</span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Boolean</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> redisCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">opsForValue</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">setIfAbsent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockKey</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> id</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Objects</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equals</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">Boolean</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">FALSE</span><span style="color:#89DDFF;">)){</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 没拿到锁稍后再试  直接返回 或者 休眠重试</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 拿到锁继续执行</span></span></code></pre></div></blockquote><h4 id="难点" tabindex="-1">难点 <a class="header-anchor" href="#难点" aria-label="Permalink to &quot;难点&quot;">​</a></h4><p>任务没执行完锁过期的情况</p><blockquote><p>正常都应该先预估好任务执行时间来设置过期时间，尽量减少这种情况，特殊情况还是发生了的话，可以根据具体场景用以下处理方式<br><strong>执行中状态标记</strong>: 在缓存加个任务执行状态标记，尝试获取锁时先检查是否有任务在执行中<br><strong>队列机制</strong>: 获取锁后先把任务放到队列里，从队列中获取待执行任务，任务放在队列中等待，就可以不依赖锁的状态<br><strong>分布式协调工具</strong>: 使用分布式协调工具如ZooKeeper、etcd或Consul等来实现分布式锁。这些工具提供了更健壮和可靠的分布式锁机制，并能够解决锁过期的问题。它们通常基于分布式一致性算法实现，可以确保锁在任务执行完成前不会过期。</p></blockquote></blockquote><h3 id="分布式事务" tabindex="-1">分布式事务 <a class="header-anchor" href="#分布式事务" aria-label="Permalink to &quot;分布式事务&quot;">​</a></h3><blockquote><h4 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h4><blockquote><p>原子性（Atomicity）：所有事务操作必须被视为一个整体，一旦其中一个操作失败，则整个事务必须回滚，以确保所有节点上的数据状态一致。<br> 一致性（Consistency）：在事务开始和结束时，所有节点的数据必须处于一致状态。这意味着所有参与者必须遵守相同的规则和约束条件，以确保整个事务的一致性。<br> 隔离性（Isolation）：不同的事务应该相互隔离，以避免互相干扰和结果不确定性。<br> 持久性（Durability）：一旦事务提交，所做的更改必须在所有节点上被持久化，以确保数据不会因节点故障或其他原因而丢失。</p></blockquote><h4 id="场景-1" tabindex="-1">场景 <a class="header-anchor" href="#场景-1" aria-label="Permalink to &quot;场景&quot;">​</a></h4><blockquote><p>保证订单、库存、支付等一致性可靠性</p></blockquote><h4 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h4><h5 id="共识算法" tabindex="-1">共识算法 <a class="header-anchor" href="#共识算法" aria-label="Permalink to &quot;共识算法&quot;">​</a></h5><blockquote><p>用于在分布式系统中达成一致意见的算法。<br> 它们被设计为在存在网络延迟、节点故障和恶意节点的情况下，使得多个节点能够就某个事务或决策达成一致。</p></blockquote><h5 id="paxos" tabindex="-1">Paxos <a class="header-anchor" href="#paxos" aria-label="Permalink to &quot;Paxos&quot;">​</a></h5><blockquote><p>Paxos是一种经典的共识算法，用于解决分布式一致性问题。它通过一系列提议、承诺和接受阶段来达成共识。</p></blockquote><h5 id="raft" tabindex="-1">Raft <a class="header-anchor" href="#raft" aria-label="Permalink to &quot;Raft&quot;">​</a></h5><blockquote><p>Raft是一种相对较新的共识算法，与Paxos类似，但比Paxos更易于理解和实现。Raft将共识问题划分为领导者选举、日志复制和安全性三个子问题，并通过这些子问题的机制来实现一致性。</p><ol><li>名词 <ul><li>复制状态机</li></ul></li></ol></blockquote><h5 id="byzantine-fault-tolerance-bft-算法" tabindex="-1">Byzantine Fault Tolerance (BFT)算法 <a class="header-anchor" href="#byzantine-fault-tolerance-bft-算法" aria-label="Permalink to &quot;Byzantine Fault Tolerance (BFT)算法&quot;">​</a></h5><blockquote><p>BFT算法是一类针对拜占庭容错问题设计的共识算法。它能够在有恶意节点存在的情况下保证系统的一致性，适用于对安全性要求较高的场景。</p></blockquote><h5 id="practical-byzantine-fault-tolerance-pbft-算法" tabindex="-1">Practical Byzantine Fault Tolerance (PBFT)算法 <a class="header-anchor" href="#practical-byzantine-fault-tolerance-pbft-算法" aria-label="Permalink to &quot;Practical Byzantine Fault Tolerance (PBFT)算法&quot;">​</a></h5><blockquote><p>PBFT是一种BFT算法的具体实现，旨在解决拜占庭容错问题。它通过节点之间的互相通信和消息交换来达成一致，要求超过两个-thirds的节点是诚实和正常工作的。</p></blockquote><h4 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h4><blockquote><h5 id="两阶段提交" tabindex="-1">两阶段提交 <a class="header-anchor" href="#两阶段提交" aria-label="Permalink to &quot;两阶段提交&quot;">​</a></h5><blockquote><p>描述: 包含准备阶段、提交阶段<br> 实现: <img src="`+D+'" alt="image"> 缺点: 多个服务都依赖事务管理器，系统并发能力下降<br> 难点: 协调者和参与者之间通信故障怎么处理 <img src="'+g+'" alt="image"></p></blockquote><h5 id="三阶段提交" tabindex="-1">三阶段提交 <a class="header-anchor" href="#三阶段提交" aria-label="Permalink to &quot;三阶段提交&quot;">​</a></h5><blockquote><p>描述: 跟二阶段相比第三阶段失败有时也允许提交事务 <img src="'+q+'" alt="image"></p></blockquote><h5 id="at模式" tabindex="-1">AT模式 <a class="header-anchor" href="#at模式" aria-label="Permalink to &quot;AT模式&quot;">​</a></h5><blockquote><p>描述: 二阶段提交的变种，多了<strong>补偿机制</strong><img src="'+k+'" alt="image"><img src="'+m+'" alt="image"><img src="'+F+'" alt="image"></p></blockquote><h5 id="tcc模式" tabindex="-1">TCC模式 <a class="header-anchor" href="#tcc模式" aria-label="Permalink to &quot;TCC模式&quot;">​</a></h5><blockquote><p>描述: 基于补偿机制的分布式协议，通过三个阶段实现事务原子性、一致性 <img src="'+f+'" alt="image"></p></blockquote><h5 id="sega模式" tabindex="-1">sega模式 <a class="header-anchor" href="#sega模式" aria-label="Permalink to &quot;sega模式&quot;">​</a></h5><blockquote><p>基于事件方式<br> 基于命令方式</p></blockquote></blockquote><h4 id="实现-1" tabindex="-1">实现 <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;实现&quot;">​</a></h4><blockquote><h5 id="ali-seta" tabindex="-1">ali seta <a class="header-anchor" href="#ali-seta" aria-label="Permalink to &quot;ali seta&quot;">​</a></h5><blockquote><p>用于对性能要求比较低的场景<br> 对代码有侵入<br> 原理：</p><blockquote><p>Ali SETA 将事务分为 TCC 事务和 SAGA 事务两种类型。 todo</p></blockquote></blockquote><h5 id="异步消息补偿" tabindex="-1">异步消息补偿 <a class="header-anchor" href="#异步消息补偿" aria-label="Permalink to &quot;异步消息补偿&quot;">​</a></h5><blockquote><p>用于对性能要求比较高的场景<br> 在服务异常时记录下来，或者放入消息队列，异步做补偿机制</p></blockquote></blockquote></blockquote><h2 id="业务场景" tabindex="-1">业务场景 <a class="header-anchor" href="#业务场景" aria-label="Permalink to &quot;业务场景&quot;">​</a></h2><h3 id="秒杀" tabindex="-1">秒杀 <a class="header-anchor" href="#秒杀" aria-label="Permalink to &quot;秒杀&quot;">​</a></h3><p>redis</p><p>jmeter压测</p><p>。。。。</p><h2 id="本地缓存" tabindex="-1">本地缓存 <a class="header-anchor" href="#本地缓存" aria-label="Permalink to &quot;本地缓存&quot;">​</a></h2><p>本地缓存方案中的应用进程和缓存进程在同一个进程，没有网络开销，访问速度快，但受限于内存，不适合存储大量数据。本地缓存主要有Guava cache，Caffeine，Encache等，还可以通过HashMap自实现一套本地缓存机制。</p><h3 id="cacheable" tabindex="-1">@Cacheable <a class="header-anchor" href="#cacheable" aria-label="Permalink to &quot;@Cacheable&quot;">​</a></h3><p>cacheManager 缓存管理器 cacheResolver 缓存解析器 配置一种缓存时不用指定，多个的时候需要指定使用哪一种缓存</p><h4 id="参考文档-3" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档-3" aria-label="Permalink to &quot;参考文档&quot;">​</a></h4><p><a href="https://blog.csdn.net/qq_44936392/article/details/121476927" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_44936392/article/details/121476927</a></p><p><img src="'+x+`" alt="image-20230129110956423"></p><h3 id="guava" tabindex="-1">guava <a class="header-anchor" href="#guava" aria-label="Permalink to &quot;guava&quot;">​</a></h3><h4 id="描述" tabindex="-1">描述 <a class="header-anchor" href="#描述" aria-label="Permalink to &quot;描述&quot;">​</a></h4><p>guava缓存是谷歌开源的一种本地缓存，缓存是使用本机的内存来存储的，实现原理类似于java老版本ConcurrentHashMap</p><h4 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-label="Permalink to &quot;使用方式&quot;">​</a></h4><p>1、导包</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;dependency&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">			&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">			&lt;artifactId&gt;guava&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">			&lt;version&gt;19.0&lt;/version&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">		&lt;/dependency&gt;</span></span></code></pre></div><p>2、</p><h4 id="缓存清除策略" tabindex="-1">缓存清除策略 <a class="header-anchor" href="#缓存清除策略" aria-label="Permalink to &quot;缓存清除策略&quot;">​</a></h4><p>① 基于存活时间的清除策略 expireAfterWrite 写缓存后多久过期 expireAfterAccess 读写缓存后多久过期 存活时间策略可以单独设置或组合配置 ② 基于容量的清除策略 通过CacheBuilder.maximumSize(long)方法可以设置Cache的最大容量数，当缓存数量达到或接近该最大值时，Cache将清除掉那些最近最少使用的缓存</p><p>③ 基于权重的清除 策略 使用CacheBuilder.weigher(Weigher)指定一个权重函数，并且用CacheBuilder.maximumWeight(long)指定最大总重。</p><h4 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h4><p>vending用到的 参考文档 <a href="https://blog.csdn.net/zw147258369/article/details/125484533" target="_blank" rel="noreferrer">https://blog.csdn.net/zw147258369/article/details/125484533</a></p><h3 id="caffeine" tabindex="-1">Caffeine <a class="header-anchor" href="#caffeine" aria-label="Permalink to &quot;Caffeine&quot;">​</a></h3><h4 id="描述-1" tabindex="-1">描述 <a class="header-anchor" href="#描述-1" aria-label="Permalink to &quot;描述&quot;">​</a></h4><h4 id="使用方式-1" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式-1" aria-label="Permalink to &quot;使用方式&quot;">​</a></h4><p>1、导包</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;dependency&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            &lt;artifactId&gt;caffeine&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        &lt;/dependency&gt;</span></span></code></pre></div><p>resource-management-system用到的</p><h3 id="encache" tabindex="-1">Encache <a class="header-anchor" href="#encache" aria-label="Permalink to &quot;Encache&quot;">​</a></h3><p><a href="https://blog.csdn.net/weixin_42072632/article/details/125091305" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_42072632/article/details/125091305</a></p><h2 id="底层" tabindex="-1">底层 <a class="header-anchor" href="#底层" aria-label="Permalink to &quot;底层&quot;">​</a></h2><h3 id="字节码插件-jclasslib" tabindex="-1">字节码插件 jclasslib <a class="header-anchor" href="#字节码插件-jclasslib" aria-label="Permalink to &quot;字节码插件 jclasslib&quot;">​</a></h3><p><img src="`+P+'" alt="idea怎么使用jclasslib插件查看字节码"></p><p><img src="'+v+`" alt="idea怎么使用jclasslib插件查看字节码"></p><h3 id="动态代理" tabindex="-1">动态代理 <a class="header-anchor" href="#动态代理" aria-label="Permalink to &quot;动态代理&quot;">​</a></h3><p>jdk</p><p>cglib</p><p><a href="https://juejin.cn/post/6844904036202905614" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904036202905614</a></p><p>动态加载是个难题，包你都重新打了，不打包你的class没法加载到虚拟机内存中，重启是免不了的。 通用的方案就是集群，高级一点的，可以看看osgi或spring module</p><h2 id="kafka" tabindex="-1">kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to &quot;kafka&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">./kafka-topics.sh --bootstrap-server PLAINTEXT://124.223.75.221:9092 --create --topic topicName2</span></span>
<span class="line"><span style="color:#A6ACCD;"> ./kafka-topics.sh --bootstrap-server PLAINTEXT://VM-4-11-centos:9092 --create --topic topicName</span></span>
<span class="line"><span style="color:#A6ACCD;"> ./kafka-topics.sh --bootstrap-server PLAINTEXT://zk:9092 --create --topic topicName</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">//将fos.txt文件中所有字符读取回来</span></span>
<span class="line"><span style="color:#A6ACCD;">        File file = new File(&quot;C:\\\\Users\\\\fm00894\\\\Desktop\\\\新建文件夹 (3)\\\\1.txt&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        FileInputStream fis = new FileInputStream(file);</span></span>
<span class="line"><span style="color:#A6ACCD;">        byte[] bytes = new byte[(int)file.length()];</span></span>
<span class="line"><span style="color:#A6ACCD;">        fis.read(bytes);</span></span>
<span class="line"><span style="color:#A6ACCD;">        /*</span></span>
<span class="line"><span style="color:#A6ACCD;">            String提供的构造器</span></span>
<span class="line"><span style="color:#A6ACCD;">            String(byte[] data,Charset charset)</span></span>
<span class="line"><span style="color:#A6ACCD;">            将给定的字节数组data中所有的字节按照给定的字符集charset转换为一个字符串</span></span>
<span class="line"><span style="color:#A6ACCD;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        String line = new String(bytes, StandardCharsets.UTF_8);</span></span>
<span class="line"><span style="color:#A6ACCD;">//        System.out.println(line);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        fis.close();</span></span></code></pre></div><p>学习</p><p>异步线程，traceid丢失问题</p><p><a href="https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html" target="_blank" rel="noreferrer">https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html</a></p><p><img src="`+S+`" alt="synchronized"></p><h2 id="学习资料" tabindex="-1">学习资料 <a class="header-anchor" href="#学习资料" aria-label="Permalink to &quot;学习资料&quot;">​</a></h2><p>1、网站</p><p>2、电子书</p><p>多线程事务 <a href="https://mp.weixin.qq.com/s/vN6zOECK_PDXltJ8k22h0A" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/vN6zOECK_PDXltJ8k22h0A</a></p><p>分布式锁 [Zookeeper 都有哪些应⽤场景？] [使⽤ Redis 如何设计分布式锁？使⽤ Zookeeper 来设计分布式锁可以吗？以上两种分布式锁的实现⽅ 式哪种效率⽐较⾼？] 分布式事务 [分布式事务了解吗？你们如何解决分布式事务问题的？TCC 如果出现⽹络连不通怎么办？XA 的⼀致性 如何保证？] 分布式会话 [集群部署时的分布式 Session 如何实现？] ⾼可⽤架构 [Hystrix 介绍] [电商⽹站详情⻚系统架构] [Hystrix 线程池技术实现资源隔离] [Hystrix 信号量机制实现资源隔离] [Hystrix 隔离策略细粒度控制] [深⼊ Hystrix 执⾏时内部原理] [基于 request cache 请求缓存技术优化批量商品数据查询接⼝] [基于本地缓存的 fallback 降级机制] [深⼊ Hystrix 断路器执⾏原理] [深⼊ Hystrix 线程池隔离与接⼝限流] [基于 timeout 机制为服务接⼝调⽤超时提供安全保护] ⾼可⽤系统 如何设计⼀个⾼可⽤系统？ 限流 如何限流？在⼯作中是怎么做的？说⼀下具体的实现？ 熔断 如何进⾏熔断？ 熔断框架都有哪些？具体实现原理知道吗？</p><p> 降级<br>  降级<br>  降级 如何进⾏降级？</p><p>官网 <a href="https://square.github.io/okhttp/" target="_blank" rel="noreferrer">https://square.github.io/okhttp/</a> okhttp3 是java语言封装的请求库 流式接口 websocket</p><p>undownloadprogress</p><h2 id="乱七八糟的代码记得整理" tabindex="-1">乱七八糟的代码记得整理 <a class="header-anchor" href="#乱七八糟的代码记得整理" aria-label="Permalink to &quot;乱七八糟的代码记得整理&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@EnableFeignClients</span></span>
<span class="line"><span style="color:#A6ACCD;">@FeignClient(contextId = &quot;ecologyClient&quot;, name = &quot;\${saas.ecologyClient.feign.name:ECOLOGY-ADMIN-APPLICATION}&quot;, url = &quot;\${saas.ecologyClient.feign.url}&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public interface EcologyClient {</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    @PostMapping(value = &quot;/ecology/api/token/getAppAccessToken&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    EcologyBaseResponse&lt;EcologyGetAppAccessTokenResponse&gt; getAppAccessToken(@RequestBody EcologyGetAppAccessTokenRequest request);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">@Override</span></span>
<span class="line"><span style="color:#A6ACCD;">@Cacheable(&quot;menu&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public Menu findById(String id) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    Menu menu = this.getById(id);</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (menu != null){</span></span>
<span class="line"><span style="color:#A6ACCD;">        System.out.println(&quot;menu.name = &quot; + menu.getName());</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return menu;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"> Optional&lt;A&gt; firstA= AList.stream()</span></span>
<span class="line"><span style="color:#A6ACCD;">                          .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName()))</span></span>
<span class="line"><span style="color:#A6ACCD;">                          .findFirst()</span></span>
<span class="line"><span style="color:#A6ACCD;">                          .ifPresent(a -&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">                              a.setUserName(&quot;明明&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">                          })</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">log.info(&quot;message: {} response:{}&quot;, new Object[]{&quot;查询全部省市区结果&quot;,JSON.toJSONString(resp)});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">  Method getValueMethod = ReflectionUtils.findMethod(enumClass, validateMethod, String.class);</span></span>
<span class="line"><span style="color:#A6ACCD;">                Object returnValue = ReflectionUtils.invokeMethod(getValueMethod, null, value.toString());</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">				@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE})</span></span>
<span class="line"><span style="color:#A6ACCD;">@Retention(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="color:#A6ACCD;">@Constraint(validatedBy = EnumValueCheck.Validator.class)</span></span>
<span class="line"><span style="color:#A6ACCD;">public @interface EnumValueCheck {</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    String message() default &quot;参数值不在允许的范围内&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    Class&lt;?&gt;[] groups() default {};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    Class&lt;? extends Payload&gt;[] payload() default {};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    /**</span></span>
<span class="line"><span style="color:#A6ACCD;">     * 枚举类名</span></span>
<span class="line"><span style="color:#A6ACCD;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    Class&lt;? extends Enum&lt;?&gt;&gt; enumClass();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    /**</span></span>
<span class="line"><span style="color:#A6ACCD;">     * 校验方法</span></span>
<span class="line"><span style="color:#A6ACCD;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    String enumMethod() default &quot;isValid&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    @Slf4j</span></span>
<span class="line"><span style="color:#A6ACCD;">    class Validator implements ConstraintValidator&lt;EnumValueCheck, Object&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        private Class&lt;? extends Enum&lt;?&gt;&gt; enumClass;</span></span>
<span class="line"><span style="color:#A6ACCD;">        private String validateMethod;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        @Override</span></span>
<span class="line"><span style="color:#A6ACCD;">        public void initialize(EnumValueCheck enumValue) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            validateMethod = enumValue.enumMethod();</span></span>
<span class="line"><span style="color:#A6ACCD;">            enumClass = enumValue.enumClass();</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        @Override</span></span>
<span class="line"><span style="color:#A6ACCD;">        public boolean isValid(Object value, ConstraintValidatorContext constraintValidatorContext) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            try {</span></span>
<span class="line"><span style="color:#A6ACCD;">                Method getValueMethod = ReflectionUtils.findMethod(enumClass, validateMethod, String.class);</span></span>
<span class="line"><span style="color:#A6ACCD;">                Object returnValue = ReflectionUtils.invokeMethod(getValueMethod, null, value.toString());</span></span>
<span class="line"><span style="color:#A6ACCD;">                if (returnValue instanceof Boolean) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    return (Boolean) returnValue;</span></span>
<span class="line"><span style="color:#A6ACCD;">                } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    //方法不满足要求，执行降级</span></span>
<span class="line"><span style="color:#A6ACCD;">                    return Boolean.TRUE;</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            } catch (Throwable e) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                log.error(&quot;枚举类校验执行验证降级e:{}&quot;, FmStringUtils.chang2OneLine(ExceptionUtils.getFullStackTrace(e)));</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">            return Boolean.TRUE;</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">springboot给所有请求加统一前缀</span></span>
<span class="line"><span style="color:#A6ACCD;">server.servlet.context-path=polaris-center</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">1、请求重试</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;dependency&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;groupId&gt;com.github.rholder&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;artifactId&gt;guava-retrying&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;version&gt;2.0.0&lt;/version&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Retryer&lt;Map&lt;String, Object&gt;&gt; retryer = RetryerBuilder.&lt;Map&lt;String, Object&gt;&gt;newBuilder()</span></span>
<span class="line"><span style="color:#A6ACCD;">        .retryIfResult(result -&gt; !&quot;100&quot;.equals(result.get(&quot;code&quot;).toString()))</span></span>
<span class="line"><span style="color:#A6ACCD;">        .withStopStrategy(StopStrategies.stopAfterAttempt(5))//重试次数</span></span>
<span class="line"><span style="color:#A6ACCD;">        .withWaitStrategy(WaitStrategies.fixedWait(100, TimeUnit.MILLISECONDS))//间隔100毫秒一次</span></span>
<span class="line"><span style="color:#A6ACCD;">        .build();</span></span>
<span class="line"><span style="color:#A6ACCD;">Map&lt;String, Object&gt; map = retryer.call(getOrderBySessionId(reqVo));</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">2、Spring Cloud Sleuth？</span></span>
<span class="line"><span style="color:#A6ACCD;">  Spring Cloud Sleuth是Spring Cloud提供的分布式系统服务链追踪组件</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;/dependency&gt;</span></span></code></pre></div><h1 id="其他待整理" tabindex="-1">其他待整理 <a class="header-anchor" href="#其他待整理" aria-label="Permalink to &quot;其他待整理&quot;">​</a></h1><p>ForwardingNode 解决扩容时候查询问题 ReservationNode 解决计算时对象为空问题</p><p>集群高可用三方软件</p><p>proxy、keepalived</p><p>VRRP协议 它可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。控制虚拟路由器 IP 地址的 VRRP 路由器称为主路由器，它负责转发数据包到这些虚拟 IP 地址。一旦主路由器不可用，这种选择过程就提供了动态的<strong>故障转移</strong>机制</p><h2 id="cpu标高" tabindex="-1">CPU标高 <a class="header-anchor" href="#cpu标高" aria-label="Permalink to &quot;CPU标高&quot;">​</a></h2><h2 id="服务大概多少qps" tabindex="-1">服务大概多少QPS <a class="header-anchor" href="#服务大概多少qps" aria-label="Permalink to &quot;服务大概多少QPS&quot;">​</a></h2><p><a href="http://49.65.100.179:9010/#/login" target="_blank" rel="noreferrer">http://49.65.100.179:9010/#/login</a><a href="http://tongyang.xyz/" target="_blank" rel="noreferrer">http://tongyang.xyz/</a><a href="http://tongyang.xyz:9010/" target="_blank" rel="noreferrer">http://tongyang.xyz:9010/</a><a href="https://tongyang.xyz/" target="_blank" rel="noreferrer">https://tongyang.xyz/</a></p><p>domain 要钱 godaddy 要钱 namescheap</p><p>XO38-FREE</p><p>dnspod <a href="https://hostry.com/?d=1" target="_blank" rel="noreferrer">https://hostry.com/?d=1</a></p><p>eu.org申请免费域名 免费域名申请教程</p><p>表数据量 qps 微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想</p><p>商品表11w 有效的估计就1w 门店 5000 订单表 近三个月200w 2022 1000w 2021 500w 订单商品表 近三个月800w 2022 5000w 三个月归档</p><p>微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想</p><p>Kubernetes ？？日志采集</p>`,230),T=[_];function j(M,B,w,I,L,R){return s(),n("div",null,T)}const O=a(E,[["render",j]]);export{N as __pageData,O as default};
